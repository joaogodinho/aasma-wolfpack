to init-wolves
  set sheep-position false
  set msg-sheep-position false
  set desire false
  set intention build-empty-intention
  set plan build-empty-plan
end

to wolf-deliberative-loop

  ifelse not (empty-plan? plan or intention-succeeded? intention)
  [   
    execute-plan-action
    update-beliefs
  ]
  [
    update-beliefs
    ;; Check the wolf's options
    set desire BDI-options
    set intention BDI-filter
    set plan build-plan-for-intention intention

    ;; If it could not build a plan, the wolf should behave as a reactive agent
    if empty-plan? plan
      [ wolf-reactive-loop ]

    if sheep-position != false and wolves-in-sight != false
      [ 
        let msg list "sheep-position" sheep-position
        show msg
        foreach sort wolves-in-sight [ send-message-to-wolf [ who ] of ? msg ] 
      ]
  ]
end

to-report BDI-options
  if wolf-near-sheep?
    [ report false ]
  if sheep-position != false
    [ report "move-to-sheep" ]
    
  report false
end

to-report BDI-filter
  if desire != false
    [ report sheep-position ]
    
  report build-empty-intention
end

to-report build-empty-plan
  report []
end

to-report empty-plan? [pplan]
  report empty? pplan
end

to-report build-empty-intention
  report []
end

to-report empty-intention? [iintention]
  report not is-patch? iintention
end

to-report intention-succeeded? [iintention]
  if empty-intention? iintention
    [ report false ]

  report patch-here = get-intention-position iintention
end

to update-beliefs
  set sheep-position wolf-has-sheep-in-sight
  if sheep-position = false and msg-sheep-position != false
  [ set sheep-position msg-sheep-position ]
  
  set msg-sheep-position false
end

to execute-plan-action
  let currentInstruction 0

  set currentInstruction get-plan-first-instruction plan

  ifelse free-patch? currentInstruction
  [ wolf-move-adjacent currentInstruction
    set plan remove-plan-first-instruction plan ]
  [ set plan build-plan-for-intention intention ]
end

to-report get-plan-first-instruction [pplan]
  report first pplan
end

to-report get-intention-position [iintention]
  report iintention
end

to-report build-plan-for-intention [iintention]
  let new-plan build-empty-plan

  if not empty-intention? iintention
  [ set new-plan build-path-plan wolf-adjacent-positions get-intention-position iintention ]

  report new-plan
end

to-report build-path-plan [adjpos posf]
  let newPlan 0
  let path 0

  set newPlan build-empty-plan
  set path find-path adjpos posf
  foreach path
    [ set newPlan add-instruction-to-plan newPlan build-instruction ? ]

  report newPlan
end

to-report add-instruction-to-plan [pplan iinstruction]
  report lput iinstruction pplan
end

to-report build-instruction [vvalue]
  report vvalue
end

to-report remove-plan-first-instruction [pplan]
  report butfirst pplan
end

to-report find-path [PossiblePos FinalPos]
  let path [] 
  set path lput find-closest-patch PossiblePos FinalPos path
  let currentPatch first path
  
  while [ not member? currentPatch [ neighbors4 ] of FinalPos ]
  [
    ifelse WOLVES-DIAGONALS
    [ set currentPatch find-closest-patch [ neighbors ] of currentPatch FinalPos ]
    [ set currentPatch find-closest-patch [ neighbors4 ] of currentPatch FinalPos ]

    set path lput currentPatch path
  ]
  
  report path
end

to send-message-to-wolf [id-wolf msg]
  ask wolf id-wolf [new-message msg]
end

to new-message [msg]
  show msg
  if item 0 msg = "sheep-position"
  [
    set msg-sheep-position item 1 msg
  ]
end




